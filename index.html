<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="theme-color" content="#f1f4fe" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <title>Indie Maps</title>
    <link rel="icon" href="/favicon.svg" type="image/svg+xml" />
    <link rel="apple-touch-icon" href="/favicon.svg" />
    <link rel="stylesheet" href="https://unpkg.com/maplibre-gl/dist/maplibre-gl.css" />
    <style>
      :root {
        --bg: #f5f6f8;
        --panel: #ffffff;
        --panel-alt: #e7e9ef;
        --accent: #1a73e8;
        --accent-dark: #174ea6;
        --muted: #5f6368;
        --border: #cfd6e4;
        --shadow: 0 6px 12px rgba(15, 23, 42, 0.15);
        font-family: 'Verdana', 'Tahoma', sans-serif;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        background: radial-gradient(circle at top, #ffffff 0%, #dfe6ff 35%, #b6c7f6 100%);
        color: #1a1a1a;
        display: flex;
        justify-content: center;
        padding: 16px;
      }

      .shell {
        width: min(1200px, 100%);
        min-height: 90vh;
        background: linear-gradient(180deg, #fefefe 0%, #f1f4fe 100%);
        border-radius: 18px;
        border: 1px solid var(--border);
        box-shadow: var(--shadow);
        padding: 24px;
        display: grid;
        gap: 16px;
      }

      header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        flex-wrap: wrap;
        gap: 12px;
      }

      header h1 {
        margin: 0;
        font-size: 1.7rem;
        letter-spacing: 0.08em;
      }

      .toolbar {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        align-items: center;
      }

      .toolbar label {
        display: flex;
        align-items: center;
        gap: 6px;
        font-weight: bold;
        font-size: 0.9rem;
      }

      .toolbar select,
      .toolbar button {
        appearance: none;
        border: 1px solid var(--border);
        border-radius: 6px;
        padding: 6px 12px;
        background: linear-gradient(180deg, #edf1ff, #dfe6ff);
        font-weight: bold;
        font-size: 0.85rem;
        cursor: pointer;
        box-shadow: inset 0 1px rgba(255, 255, 255, 0.8);
      }

      .toolbar button:disabled {
        opacity: 0.4;
        cursor: not-allowed;
      }

      .map-shell {
        position: relative;
        background: var(--panel);
        border-radius: 16px;
        border: 2px solid var(--border);
        padding: 16px;
        box-shadow: 0 12px 30px rgba(0, 0, 0, 0.08);
        display: grid;
        gap: 16px;
      }

      .search-area {
        display: grid;
        gap: 10px;
      }

      .search-row {
        display: flex;
        gap: 8px;
        background: var(--panel-alt);
        padding: 10px;
        border-radius: 12px;
        border: 1px solid var(--border);
        box-shadow: inset 0 1px rgba(255, 255, 255, 0.8);
      }

      .search-row input {
        flex: 1;
        border: 1px solid var(--border);
        border-radius: 6px;
        padding: 10px 12px;
        font-size: 1rem;
        background: #fff;
      }

      .search-row button {
        min-width: 48px;
      }

      .search-row .small-btn {
        width: 36px;
        padding: 0;
        font-size: 1.2rem;
        line-height: 1;
      }

      .results {
        max-height: 220px;
        overflow-y: auto;
        background: #f8f9ff;
        border: 1px inset #cfd6e4;
        border-radius: 10px;
        padding: 10px;
        display: grid;
        gap: 6px;
      }

      .hidden {
        display: none !important;
      }

      body.embed-mode {
        background: transparent;
      }

      .embed-mode .shell {
        border: none;
        background: transparent;
        box-shadow: none;
        padding: 0;
      }

      .embed-mode header,
      .embed-mode .toolbar,
      .embed-mode .search-area,
      .embed-mode .results,
      .embed-mode .history-shell,
      .embed-mode .status-bar {
        display: none;
      }

      .embed-mode .map-shell {
        border-radius: 0;
        border: none;
        padding: 0;
        box-shadow: none;
        background: transparent;
      }

      .results-header {
        font-size: 0.85rem;
        letter-spacing: 0.1em;
        text-transform: uppercase;
        color: var(--muted);
      }

      .result-row {
        background: #fff;
        border: 1px solid transparent;
        border-radius: 8px;
        padding: 10px 12px;
        cursor: pointer;
        display: flex;
        flex-direction: column;
        gap: 4px;
        text-align: left;
      }

      .result-row:hover,
      .result-row.active {
        border-color: var(--accent);
        background: linear-gradient(90deg, #e4edff, #f2f5ff);
      }

      .result-row strong {
        font-size: 0.95rem;
      }

      .result-row small {
        color: var(--muted);
      }

      .result-badge {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 4px;
        border-radius: 999px;
        padding: 2px 8px;
        font-size: 0.7rem;
        letter-spacing: 0.1em;
        text-transform: uppercase;
      }

      .result-badge.start {
        background: rgba(15, 157, 88, 0.1);
        color: #0f9d58;
        border: 1px solid rgba(15, 157, 88, 0.3);
      }

      .result-badge.end {
        background: rgba(66, 133, 244, 0.1);
        color: #4285f4;
        border: 1px solid rgba(66, 133, 244, 0.3);
      }

      .user-location-dot {
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: rgba(66, 133, 244, 0.9);
        border: 3px solid rgba(255, 255, 255, 0.95);
        box-shadow: 0 0 8px rgba(66, 133, 244, 0.7);
      }

      .history-shell {
        background: #fff;
        border-radius: 10px;
        border: 1px solid var(--border);
        padding: 10px 12px;
        box-shadow: inset 0 1px rgba(255, 255, 255, 0.8);
        display: grid;
        gap: 6px;
      }

      .history-shell h3 {
        margin: 0;
        font-size: 0.85rem;
        letter-spacing: 0.1em;
        text-transform: uppercase;
        color: var(--muted);
      }

      .history-list {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
      }

      .history-item {
        border: 1px solid var(--border);
        background: linear-gradient(180deg, #edf1ff, #f8f9ff);
        padding: 6px 10px;
        border-radius: 6px;
        font-size: 0.85rem;
        cursor: pointer;
      }

      .history-item:hover {
        border-color: var(--accent);
      }

      .status-bar {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        font-size: 0.9rem;
        color: var(--muted);
      }

      .status-bar span {
        background: #fff;
        padding: 6px 10px;
        border-radius: 6px;
        border: 1px solid var(--border);
      }

      #map-container {
        position: relative;
        min-height: 420px;
        border-radius: 14px;
        overflow: hidden;
        border: 1px solid #b0b8c9;
      }

      #map {
        width: 100%;
        height: 100%;
        min-height: 400px;
      }

      @media (max-width: 850px) {
        body {
          padding: 8px;
        }

        .shell {
          padding: 16px;
        }

        .search-row {
          flex-wrap: wrap;
        }
      }
    </style>
  </head>
  <body>
    <div class="shell">
      <header>
        <h1>
          <span style="color:#4285f4">I</span>
          <span style="color:#db4437">n</span>
          <span style="color:#f4b400">d</span>
          <span style="color:#0f9d58">i</span>
          <span style="color:#4285f4">e</span>
          <span style="color:#db4437"> </span>
          <span style="color:#f4b400">M</span>
          <span style="color:#0f9d58">a</span>
          <span style="color:#4285f4">p</span>
          <span style="color:#db4437">s</span>
        </h1>
        <div class="toolbar">
          <label>
            Units:
            <select data-units-select>
              <option value="metric">Metric</option>
              <option value="imperial">Imperial</option>
            </select>
          </label>
          <button type="button" data-clear-route disabled>Clear route</button>
        </div>
      </header>
      <div class="map-shell">
        <div class="search-area">
          <form class="search-row" data-primary-form>
            <input type="search" placeholder="Search for a place" data-primary-input autocomplete="off" />
            <button type="submit">Search</button>
            <button type="button" class="small-btn" data-add-dest>+</button>
          </form>
          <form class="search-row hidden" data-dest-row>
            <input type="search" placeholder="Then search for a second location" data-dest-input autocomplete="off" />
            <button type="submit">Search</button>
            <button type="button" class="small-btn" data-remove-dest>×</button>
          </form>
        </div>
        <div class="results hidden" data-results></div>
        <div class="history-shell">
          <h3>Recent searches</h3>
          <div class="history-list" data-history></div>
        </div>
        <div class="status-bar">
          <span data-status>Ready.</span>
          <span data-route-summary>Route: none</span>
          <span data-coords>Lat: -- | Lon: -- | Zoom: --</span>
        </div>
        <div id="map-container">
          <div id="map"></div>
        </div>
      </div>
    </div>
    <script src="https://unpkg.com/maplibre-gl/dist/maplibre-gl.js"></script>
    <script>
      const map = new maplibregl.Map({
        container: 'map',
        style: 'https://tiles.openfreemap.org/styles/liberty',
        center: [13.388, 52.517],
        zoom: 9.5,
      });

      const primaryForm = document.querySelector('[data-primary-form]');
      const primaryInput = document.querySelector('[data-primary-input]');
      const destRow = document.querySelector('[data-dest-row]');
      const destForm = destRow;
      const destInput = document.querySelector('[data-dest-input]');
      const addDestBtn = document.querySelector('[data-add-dest]');
      const removeDestBtn = document.querySelector('[data-remove-dest]');
      removeDestBtn.hidden = true;
      const resultsContainer = document.querySelector('[data-results]');
      const historyList = document.querySelector('[data-history]');
      const statusText = document.querySelector('[data-status]');
      const routeSummaryText = document.querySelector('[data-route-summary]');
      const coordsText = document.querySelector('[data-coords]');
      const unitsSelect = document.querySelector('[data-units-select]');
      const clearButton = document.querySelector('[data-clear-route]');
      const showResults = () => resultsContainer.classList.remove('hidden');
      const hideResults = () => resultsContainer.classList.add('hidden');

      const HISTORY_KEY = 'indie-maps-history';
      const START_KEY = 'indie-maps-start';
      const DEST_KEY = 'indie-maps-dest';
      const DEST_QUERY_KEY = 'indie-maps-dest-query';
      const PRIMARY_QUERY_KEY = 'indie-maps-primary-query';
      const UNITS_KEY = 'indie-maps-units';
      const ROUTE_SUMMARY_KEY = 'indie-maps-route';

      const params = new URLSearchParams(window.location.search);
      const initialPrimaryParam = params.get('s');
      const initialDestParam = params.get('d');
      const isEmbed = params.get('embed') === '1';

      let historyEntries = [];
      let primaryQuery = '';
      let destQuery = '';
      let startData = null;
      let destData = null;
      let startMarker = null;
      let destMarker = null;
      let routeSummary = null;
      let routeActive = false;
      let destVisible = false;
      let userLocationMarker = null;
      let locationWatchId = null;

      const routeSourceId = 'route-source';
      const routeLineId = 'route-line';
      const routeHaloId = 'route-line-halo';

      if (isEmbed) {
        document.body.classList.add('embed-mode');
      }

      map.on('move', () => {
        const center = map.getCenter();
        coordsText.textContent = `Lat: ${center.lat.toFixed(5)} | Lon: ${center.lng.toFixed(5)} | Zoom: ${map.getZoom().toFixed(2)}`;
      });

      function updateUserLocationMarker(coords) {
        if (!coords) {
          if (userLocationMarker) {
            userLocationMarker.remove();
            userLocationMarker = null;
          }
          return;
        }
        const lat = coords.latitude ?? coords.lat;
        const lon = coords.longitude ?? coords.lon;
        if (!Number.isFinite(lat) || !Number.isFinite(lon)) {
          return;
        }
        if (userLocationMarker) {
          userLocationMarker.setLngLat([lon, lat]);
          return;
        }
        const dot = document.createElement('div');
        dot.className = 'user-location-dot';
        userLocationMarker = new maplibregl.Marker({ element: dot })
          .setLngLat([lon, lat])
          .addTo(map);
      }

      function startLocationWatch() {
        if (!navigator.geolocation || locationWatchId) {
          return;
        }
        locationWatchId = navigator.geolocation.watchPosition(
          (position) => {
            updateUserLocationMarker(position.coords);
          },
          () => {
            // ignore errors; we already show status when permission fails
          },
          { enableHighAccuracy: true, maximumAge: 5000, timeout: 15000 }
        );
      }

      function loadState() {
        const storedHistory = localStorage.getItem(HISTORY_KEY);
        if (storedHistory) {
          try {
            historyEntries = JSON.parse(storedHistory);
          } catch (error) {
            historyEntries = [];
          }
        }

        const storedStart = localStorage.getItem(START_KEY);
        if (storedStart) {
          try {
            startData = JSON.parse(storedStart);
          } catch (error) {
            startData = null;
          }
        }

        const storedDest = localStorage.getItem(DEST_KEY);
        if (storedDest) {
          try {
            destData = JSON.parse(storedDest);
          } catch (error) {
            destData = null;
          }
        }

        const storedRoute = localStorage.getItem(ROUTE_SUMMARY_KEY);
        if (storedRoute) {
          try {
            routeSummary = JSON.parse(storedRoute);
          } catch (error) {
            routeSummary = null;
          }
        }

        const storedDestQuery = localStorage.getItem(DEST_QUERY_KEY);
        if (storedDestQuery) {
          destQuery = storedDestQuery;
        }

        const storedPrimaryQuery = localStorage.getItem(PRIMARY_QUERY_KEY);
        if (storedPrimaryQuery && !initialPrimaryParam) {
          primaryInput.value = storedPrimaryQuery;
          primaryQuery = storedPrimaryQuery;
        }

        const storedUnits = localStorage.getItem(UNITS_KEY);
        if (storedUnits) {
          unitsSelect.value = storedUnits;
        }

        destVisible = false;
      }

      function saveHistory() {
        localStorage.setItem(HISTORY_KEY, JSON.stringify(historyEntries));
        renderHistory();
      }

      function addHistory(query) {
        const trimmed = query.trim();
        if (!trimmed) return;
        historyEntries = historyEntries.filter((entry) => entry.query !== trimmed);
        historyEntries.unshift({ query: trimmed, ts: Date.now() });
        if (historyEntries.length > 6) historyEntries.pop();
        saveHistory();
      }

      function renderHistory() {
        historyList.innerHTML = '';
        if (!historyEntries.length) {
          historyList.textContent = 'No recent searches.';
          return;
        }
        historyEntries.forEach((entry) => {
          const button = document.createElement('button');
          button.type = 'button';
          button.className = 'history-item';
          button.textContent = entry.query;
          button.addEventListener('click', () => {
            collapseDestRow();
            primaryInput.value = entry.query;
            runSearch('primary', entry.query, { trackHistory: true });
          });
          historyList.appendChild(button);
        });
      }

      function setStartData(data, options = {}) {
        const { store = true, placeMarker = true } = options;
        startData = data;
        if (startMarker) startMarker.remove();
        startMarker = null;
        if (data && placeMarker) {
          startMarker = new maplibregl.Marker({ color: '#0f9d58' })
            .setLngLat([data.lon, data.lat])
            .addTo(map);
        }
        if (data && store) {
          localStorage.setItem(START_KEY, JSON.stringify(data));
        }
        if (!data && store) {
          localStorage.removeItem(START_KEY);
        }
        clearButton.disabled = !(startData || destData);
        updateURL();
      }

      function setDestData(data, options = {}) {
        const { store = true, placeMarker = true, keepMarker = false } = options;
        destData = data;
        if (destMarker && placeMarker) {
          destMarker.remove();
          destMarker = null;
        }
        if (data && destVisible && placeMarker) {
          destMarker = new maplibregl.Marker({ color: '#4285f4' })
            .setLngLat([data.lon, data.lat])
            .addTo(map);
        }
        if (data && store) {
          localStorage.setItem(DEST_KEY, JSON.stringify(data));
        }
        if (!data && store) {
          localStorage.removeItem(DEST_KEY);
        }
        clearButton.disabled = !(startData || destData);
        updateURL();
      }

      function updateRouteSummaryText() {
        if (!routeSummary) {
          routeSummaryText.textContent = 'Route: none';
          return;
        }
        const suffix = routeActive && destVisible ? '' : ' (cached)';
        routeSummaryText.textContent = `Route: ${formatDistance(routeSummary.distance)} · ${formatDuration(routeSummary.duration)}${suffix}`;
      }

      function formatDistance(meters) {
        if (unitsSelect.value === 'imperial') {
          return `${(meters * 0.000621371).toFixed(1)} mi`;
        }
        return `${(meters / 1000).toFixed(1)} km`;
      }

      function formatDuration(seconds) {
        const minutes = Math.ceil(seconds / 60);
        return `${minutes} min`;
      }

      function updateURL() {
        const url = new URL(window.location);
        if (primaryQuery) {
          url.searchParams.set('s', primaryQuery);
        } else {
          url.searchParams.delete('s');
        }
        if (destVisible && destQuery) {
          url.searchParams.set('d', destQuery);
        } else {
          url.searchParams.delete('d');
        }
        history.replaceState(null, '', url.toString());
      }

      function ensureDestMarker() {
        if (!destVisible || !destData) return;
        if (destMarker) return;
        destMarker = new maplibregl.Marker({ color: '#4285f4' })
          .setLngLat([destData.lon, destData.lat])
          .addTo(map);
      }

      function removeRouteLayer() {
        [routeLineId, routeHaloId].forEach((layerId) => {
          if (map.getLayer(layerId)) map.removeLayer(layerId);
        });
        if (map.getSource(routeSourceId)) map.removeSource(routeSourceId);
        routeActive = false;
      }

      async function maybeRoute() {
        if (!startData || !destData || !destVisible) return;
        statusText.textContent = 'Calculating route...';
        try {
          const resp = await fetch(`https://router.project-osrm.org/route/v1/driving/${startData.lon},${startData.lat};${destData.lon},${destData.lat}?overview=full&geometries=geojson`);
          const json = await resp.json();
          if (!json.routes || !json.routes.length) {
            statusText.textContent = 'No route available for those points.';
            return;
          }
          const route = json.routes[0];
          ensureRouteLayer({ type: 'FeatureCollection', features: [{ type: 'Feature', geometry: route.geometry }] });
          routeSummary = { distance: route.distance, duration: route.duration };
          localStorage.setItem(ROUTE_SUMMARY_KEY, JSON.stringify(routeSummary));
          routeActive = true;
          updateRouteSummaryText();
          statusText.textContent = 'Route ready.';
        } catch (error) {
          console.error(error);
          statusText.textContent = 'Routing failed. Try again later.';
        }
      }

      function ensureRouteLayer(geojson) {
        if (map.getSource(routeSourceId)) {
          map.getSource(routeSourceId).setData(geojson);
        } else {
          map.addSource(routeSourceId, { type: 'geojson', data: geojson });
          map.addLayer({
            id: routeHaloId,
            type: 'line',
            source: routeSourceId,
            layout: { 'line-join': 'round', 'line-cap': 'round' },
            paint: { 'line-color': 'rgba(255, 255, 255, 0.6)', 'line-width': 14 },
          });
          map.addLayer({
            id: routeLineId,
            type: 'line',
            source: routeSourceId,
            layout: { 'line-join': 'round', 'line-cap': 'round' },
            paint: { 'line-color': '#4285f4', 'line-width': 6, 'line-opacity': 0.9 },
          });
        }
      }

      function collapseDestRow() {
        if (!destVisible) return;
        destRow.classList.add('hidden');
        destVisible = false;
        addDestBtn.disabled = false;
        removeDestBtn.hidden = true;
        if (destMarker) {
          destMarker.remove();
          destMarker = null;
        }
        removeRouteLayer();
        updateRouteSummaryText();
        updateURL();
      }

      function showDestRow() {
        if (destVisible) return;
        destRow.classList.remove('hidden');
        destVisible = true;
        addDestBtn.disabled = true;
        removeDestBtn.hidden = false;
        if (!destInput.value && destQuery) {
          destInput.value = destQuery;
        }
        if (destData) {
          ensureDestMarker();
          maybeRoute();
        }
        updateURL();
      }

      function clearEverything() {
        setStartData(null);
        setDestData(null);
        primaryInput.value = '';
        destInput.value = '';
        primaryQuery = '';
        destQuery = '';
        destData = null;
        destMarker && destMarker.remove();
        destMarker = null;
        collapseDestRow();
        routeSummary = null;
        routeSummaryText.textContent = 'Route: none';
        localStorage.removeItem(PRIMARY_QUERY_KEY);
        localStorage.removeItem(DEST_QUERY_KEY);
        localStorage.removeItem(ROUTE_SUMMARY_KEY);
        statusText.textContent = 'Ready.';
        removeRouteLayer();
        updateURL();
      }

      function renderResults(results, mode) {
        resultsContainer.innerHTML = '';
        if (!results.length) {
          statusText.textContent = 'No results.';
          hideResults();
          return;
        }
        showResults();
        results.forEach((result) => {
          const row = document.createElement('button');
          row.type = 'button';
          row.className = 'result-row';
          row.innerHTML = `
            <strong>${result.display_name}</strong>
            <small>${result.type}</small>
          `;
          const badge = document.createElement('span');
          badge.className = `result-badge ${mode === 'primary' ? 'start' : 'end'}`;
          badge.textContent = mode === 'primary' ? 'start' : 'destination';
          row.appendChild(badge);
          row.addEventListener('click', () => {
            applyResult(mode, result);
          });
          resultsContainer.appendChild(row);
        });
      }

      function applyResult(mode, result) {
        const payload = {
          lat: parseFloat(result.lat),
          lon: parseFloat(result.lon),
          label: result.display_name,
        };
        if (mode === 'primary') {
          setStartData(payload);
          map.flyTo({ center: [payload.lon, payload.lat], zoom: 14 });
          statusText.textContent = `Start set to ${payload.label}`;
          primaryQuery = primaryInput.value.trim();
          if (primaryQuery) {
            localStorage.setItem(PRIMARY_QUERY_KEY, primaryQuery);
            addHistory(primaryQuery);
          }
        } else {
          setDestData(payload);
          map.flyTo({ center: [payload.lon, payload.lat], zoom: 14 });
          statusText.textContent = `Destination set to ${payload.label}`;
          destQuery = destInput.value.trim();
          if (destQuery) {
            localStorage.setItem(DEST_QUERY_KEY, destQuery);
          }
        }
        updateURL();
        maybeRoute();
      }

      async function runSearch(mode, query, options = {}) {
        const trimmed = query.trim();
        if (!trimmed) return;
        if (mode === 'primary') {
          primaryInput.value = trimmed;
          primaryQuery = trimmed;
        } else {
          destInput.value = trimmed;
          destQuery = trimmed;
        }
        statusText.textContent = `Searching for ${trimmed}...`;
        resultsContainer.textContent = '';
        hideResults();
        try {
          const resp = await fetch(`https://nominatim.openstreetmap.org/search?format=json&limit=6&q=${encodeURIComponent(trimmed)}`, {
            headers: { 'Accept-Language': 'en' },
          });
          const data = await resp.json();
          if (!data.length) {
            statusText.textContent = 'No matches found.';
            return;
          }
          renderResults(data, mode);
          applyResult(mode, data[0]);
          if (mode === 'primary') {
            addHistory(trimmed);
            localStorage.setItem(PRIMARY_QUERY_KEY, trimmed);
            if (destVisible && destData) {
              maybeRoute();
            }
          } else {
            localStorage.setItem(DEST_QUERY_KEY, trimmed);
          }
        } catch (error) {
          console.error(error);
          statusText.textContent = 'Search failed. Try again later.';
        }
      }

      function locateUserAsStart() {
        if (!navigator.geolocation) {
          statusText.textContent = 'Geolocation not supported.';
          return;
        }
        statusText.textContent = 'Detecting your location...';
        navigator.geolocation.getCurrentPosition(
          (position) => {
            const { latitude, longitude } = position.coords;
            const label = 'Your location';
            const payload = { lat: latitude, lon: longitude, label };
            setStartData(payload);
            map.flyTo({ center: [longitude, latitude], zoom: 12 });
            statusText.textContent = 'Centered on your location.';
            updateUserLocationMarker(position.coords);
            startLocationWatch();
          },
          () => {
            statusText.textContent = 'Location denied.';
          }
        );
      }

      addDestBtn.addEventListener('click', () => {
        showDestRow();
        destInput.focus();
      });

      removeDestBtn.addEventListener('click', () => {
        collapseDestRow();
      });

      primaryForm.addEventListener('submit', (event) => {
        event.preventDefault();
        runSearch('primary', primaryInput.value);
        collapseDestRow();
      });

      destForm.addEventListener('submit', (event) => {
        event.preventDefault();
        if (!destVisible) return;
        runSearch('destination', destInput.value);
      });

      clearButton.addEventListener('click', () => {
        clearEverything();
      });

      unitsSelect.addEventListener('change', () => {
        localStorage.setItem(UNITS_KEY, unitsSelect.value);
        updateRouteSummaryText();
      });

      historyList.addEventListener('click', () => {
        historyList.querySelectorAll('.history-item').forEach((btn) => {
          btn.blur();
        });
      });

      map.on('load', () => {
        loadState();
        renderHistory();
        updateRouteSummaryText();
        if (startData) {
          setStartData(startData, { store: false });
          map.flyTo({ center: [startData.lon, startData.lat], zoom: 12 });
        }
        if (initialDestParam) {
          showDestRow();
          destInput.value = initialDestParam;
          runSearch('destination', initialDestParam);
        }
        if (initialPrimaryParam) {
          primaryInput.value = initialPrimaryParam;
          runSearch('primary', initialPrimaryParam);
        } else if (!startData) {
          locateUserAsStart();
        }
        startLocationWatch();
        if (!primaryQuery && primaryInput.value) {
          primaryQuery = primaryInput.value.trim();
        }
        clearButton.disabled = !(startData || destData);
      });
    </script>
  </body>
</html>
